/** Класс, отвечающий за типы блоков. */
class Block {
    static Block air;      // пустота
    static Block stone;    // стена
    static Block coin;     // монета
    static Block key;      // ключ
    static Block finish;   // финиш
    static Block lock;     // замок

    field boolean _moveThrough;

    /** Создает новый блок с параметром проходимости */
    constructor Block new(boolean moveThrough){
        let _moveThrough = moveThrough;
        return this;
    }

    /** Инициализирует все типы блоков */
    function void initBlocks(){
        let air = Block.new(true);      // пустота - проходимый
        let stone = Block.new(false);   // стена - непроходимая
        let coin = Block.new(true);     // монета - проходимая
        let key = Block.new(true);      // ключ - проходимый
        let finish = Block.new(true);   // финиш - проходимый
        let lock = Block.new(false);    // замок - непроходимый
        return;
    }

    /** Преобразует символ в блок на карте */
    function Block parse(char blockChar){
        if ((blockChar = 32) | (blockChar = 80)){ // ' ' или 'P' = воздух
            return air;
        }

        if (blockChar = 35){ // '#' = стена
            return stone;
        }

        if (blockChar = 67){ // 'C' = монета
            return coin;
        }

        if (blockChar = 75){ // 'K' = ключ
            return key;
        }

        if (blockChar = 70){ // 'F' = финиш
            return finish;
        }

        if (blockChar = 76){ // 'L' = замок
            return lock;
        }

        do Exception.throw("Block: invalid block");
        return 0;
    }

    /** 
    * Обрабатывает попытку движения игрока через блок
    * Возвращает true, если движение возможно
    */
    method boolean onTryMove(Level level, Map map, int x, int y){
        var Score score;

        if (this = lock){
            let score = level.getScore();
            if (score.hasKey()){
                do score.DecrementKeys();
                do map.removeBlock(x, y);
                return true;
            }
        }

        return false;
    }

    /** Обрабатывает нахождение игрока на блоке */
    method void onStepped(Level level, Map map, int x, int y){
        var Score score;

        if (this = coin){
            let score = level.getScore();
            do score.IncrementCoins();
            do map.removeBlock(x, y);
        }

        if (this = key){
            let score = level.getScore();
            do score.IncrementKeys();
            do map.removeBlock(x, y);
        }

        if (this = finish){
            do map.removeBlock(x, y);
        }

        return;
    }

    /** Возвращает true, если через блок можно пройти */
    method boolean canMoveThrough(){
        return _moveThrough;
    }

    /** Возвращает блок air (пустой блок) */
    function Block getAir(){
        return air;
    }

    /** Рисует блок на экране (по координатам) */
    method void render(int x, int y, int width, int height){
        var int memAddress;

        let memAddress = 16384 + (y * 32) + (x / 16);

        if (this = stone){
            do _renderFull(memAddress);
        }
        if (this = coin){
            do _renderCoin(memAddress);
        }
        if (this = key){
            do _renderKey(memAddress);
        }
        if (this = finish){
            do _renderFinish(memAddress);
        }
        if (this = lock){
            do _renderLock(memAddress);
        }
        return;
    }

    /** Отрисовка стены */
    method void _renderFull(int memAddress){
        do Memory.poke(memAddress + 0, -1);
        do Memory.poke(memAddress + 32, -1);
        do Memory.poke(memAddress + 64, -1);
        do Memory.poke(memAddress + 96, -1);
        do Memory.poke(memAddress + 128, -1);
        do Memory.poke(memAddress + 160, -1);
        do Memory.poke(memAddress + 192, -1);
        do Memory.poke(memAddress + 224, -1);
        do Memory.poke(memAddress + 256, -1);
        do Memory.poke(memAddress + 288, -1);
        do Memory.poke(memAddress + 320, -1);
        do Memory.poke(memAddress + 352, -1);
        do Memory.poke(memAddress + 384, -1);
        do Memory.poke(memAddress + 416, -1);
        do Memory.poke(memAddress + 448, -1);
        do Memory.poke(memAddress + 480, -1);
        return;
    }

    /** Отрисовка монеты */
    method void _renderCoin(int memAddress){
        do Memory.poke(memAddress + 0, 0);
        do Memory.poke(memAddress + 32, 960);
        do Memory.poke(memAddress + 64, 4080);
        do Memory.poke(memAddress + 96, 7224);
        do Memory.poke(memAddress + 128, 15324);
        do Memory.poke(memAddress + 160, 12876);
        do Memory.poke(memAddress + 192, 25158);
        do Memory.poke(memAddress + 224, 25542);
        do Memory.poke(memAddress + 256, 24646);
        do Memory.poke(memAddress + 288, 24646);
        do Memory.poke(memAddress + 320, 12364);
        do Memory.poke(memAddress + 352, 14428);
        do Memory.poke(memAddress + 384, 7224);
        do Memory.poke(memAddress + 416, 4080);
        do Memory.poke(memAddress + 448, 960);
        do Memory.poke(memAddress + 480, 0);
        return;
    }

    /** Отрисовка ключа */
    method void _renderKey(int memAddress){
        do Memory.poke(memAddress + 0, 0);
        do Memory.poke(memAddress + 32, 0);
        do Memory.poke(memAddress + 64, 0);
        do Memory.poke(memAddress + 96, 0);
        do Memory.poke(memAddress + 128, 0);
        do Memory.poke(memAddress + 160, 28);
        do Memory.poke(memAddress + 192, 38);
        do Memory.poke(memAddress + 224, 13814);
        do Memory.poke(memAddress + 256, 32766);
        do Memory.poke(memAddress + 288, 62);
        do Memory.poke(memAddress + 320, 28);
        do Memory.poke(memAddress + 352, 0);
        do Memory.poke(memAddress + 384, 0);
        do Memory.poke(memAddress + 416, 0);
        do Memory.poke(memAddress + 448, 0);
        do Memory.poke(memAddress + 480, 0);
        return;
    }

    /** Отрисовка финиша */
    method void _renderFinish(int memAddress){
        do Memory.poke(memAddress + 0, 0);
        do Memory.poke(memAddress + 32, 0);
        do Memory.poke(memAddress + 64, 16380);
        do Memory.poke(memAddress + 96, 11468);
        do Memory.poke(memAddress + 128, 11468);
        do Memory.poke(memAddress + 160, 13116);
        do Memory.poke(memAddress + 192, 13116);
        do Memory.poke(memAddress + 224, 11468);
        do Memory.poke(memAddress + 256, 11468);
        do Memory.poke(memAddress + 288, 13116);
        do Memory.poke(memAddress + 320, 13116);
        do Memory.poke(memAddress + 352, 11468);
        do Memory.poke(memAddress + 384, 11468);
        do Memory.poke(memAddress + 416, 16380);
        do Memory.poke(memAddress + 448, 12);
        do Memory.poke(memAddress + 480, 12);
        return;
    }

    /** Отрисовка замка */
    method void _renderLock(int memAddress) {
        do Memory.poke(memAddress + 0, 0);
        do Memory.poke(memAddress + 32, 2016);
        do Memory.poke(memAddress + 64, 3120);
        do Memory.poke(memAddress + 96, 2448);
        do Memory.poke(memAddress + 128, 2640);
        do Memory.poke(memAddress + 160, 2640);
        do Memory.poke(memAddress + 192, 2640);
        do Memory.poke(memAddress + 224, 2640);
        do Memory.poke(memAddress + 256, 8184);
        do Memory.poke(memAddress + 288, 12300);
        do Memory.poke(memAddress + 320, 8196);
        do Memory.poke(memAddress + 352, 8196);
        do Memory.poke(memAddress + 384, 8196);
        do Memory.poke(memAddress + 416, 8196);
        do Memory.poke(memAddress + 448, 12300);
        do Memory.poke(memAddress + 480, 8184);
        return;
    }
}
